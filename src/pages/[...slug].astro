---
/**
 * Universal Page Router
 * =====================
 * Single route handler for all languages.
 */

import { getCollection, render } from "astro:content";
import Layout from "#layout";
import {
  languages,
  defaultLanguage,
  type LanguageCode,
} from "@/config/site";
import { getIdPath, getLanguageFromId, getUrlSlug, getAlternateUrls } from "@/i18n";
import {
  getCollectionRouteInfo,
  resolveTemplatePath,
  toTemplateKey,
} from "@/content-logic";

export async function getStaticPaths() {
  const allPages = await getCollection("pages", ({ data }) => !data.draft);
  const secondaryLanguages = languages.filter((l) => l !== defaultLanguage);

  const paths = [];

  // Track slugs per locale to detect duplicates
  const slugsByLanguage = new Map<string, Map<string, string>>();
  for (const code of languages) {
    slugsByLanguage.set(code, new Map());
  }

  for (const entry of allPages) {
    const language = getLanguageFromId(entry.id);
    const slug = getUrlSlug(entry);

    // Check for duplicate permalinks within the same language
    const languageSlugMap = slugsByLanguage.get(language)!;
    if (languageSlugMap.has(slug)) {
      const existingId = languageSlugMap.get(slug);
      throw new Error(
        `Duplicate permalink "${slug || "/"}" for language "${language}": ` +
          `found in both "${existingId}" and "${entry.id}". ` +
          `Use unique permalinks or rename files.`
      );
    }
    languageSlugMap.set(slug, entry.id);

    if (language === defaultLanguage) {
      // Default language: no prefix
      // /about, /docs/getting-started, / (empty slug)
      paths.push({
        params: { slug: slug || undefined },
        props: { entry, language, allPages },
      });
    } else {
      // Non-default language: with prefix
      // /ru, /ru/about, /ru/docs/getting-started
      const fullSlug = slug ? `${language}/${slug}` : language;
      paths.push({
        params: { slug: fullSlug },
        props: { entry, language, allPages },
      });
    }
  }

  // Validate: no default language page should conflict with language prefixes
  const defaultLanguagePages = allPages.filter(
    (p) => getLanguageFromId(p.id) === defaultLanguage
  );
  const conflicts = defaultLanguagePages.filter((p) => {
    const slug = getUrlSlug(p);
    return secondaryLanguages.includes(slug as LanguageCode);
  });

  if (conflicts.length > 0) {
    const list = conflicts.map((p) => `"${p.id}"`).join(", ");
    throw new Error(
      `Default language pages cannot use slugs reserved for language prefixes: ${list}`
    );
  }

  return paths;
}

const { entry, language, allPages } = Astro.props;
// Absolute URLs for SEO meta tags (hreflang, canonical)
const alternatesAbsolute = getAlternateUrls(entry, allPages, { absolute: true });
// Relative URLs for language switcher
const alternatesRelative = getAlternateUrls(entry, allPages);
const { Content } = await render(entry);

const routeInfo = getCollectionRouteInfo(getIdPath(entry.id));
const templatePath = resolveTemplatePath(routeInfo?.collection.template);
const templates = import.meta.glob("/src/templates/**/*.astro");
const templateKey = toTemplateKey(templatePath);
const loader = templates[templateKey];
if (!loader) {
  throw new Error(`Template not found: ${templatePath}`);
}
const Template = (await loader()).default;
---

<Layout
  title={entry.data.title}
  description={entry.data.description}
  language={language}
  hreflangUrls={alternatesAbsolute}
  switcherUrls={alternatesRelative}
>
  <Template entry={entry}>
    <Content />
  </Template>
</Layout>
