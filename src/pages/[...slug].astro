---
/**
 * Universal Page Router
 * =====================
 * Single route handler for all languages.
 */

import { getCollection, render } from "astro:content";
import type { CollectionEntry } from "astro:content";
import {
  languages,
  defaultLanguage,
  type LanguageCode,
} from "@/config/site";
import { getIdPath, getLanguageFromId, getUrlSlug, getAlternateUrls } from "@/i18n";
import { resolvePageType } from "@/content-logic";
import { routeVariants } from "@/data/routes";
import { resolveRouteVariants, type ResolvedRouteVariant } from "@/routes";
import { loadTemplateLayout, loadTemplatePage } from "@/templates";

export async function getStaticPaths() {
  const allPages = await getCollection("pages", ({ data }) => !data.draft);
  const secondaryLanguages = languages.filter((l) => l !== defaultLanguage);

  const paths = [];
  const usedSlugs = new Map<string, string>();

  const addPath = (slug: string, entryId: string, source: string) => {
    const key = slug || "/";
    const existing = usedSlugs.get(key);
    if (existing) {
      throw new Error(
        `Duplicate route "${key}": "${entryId}" (${source}) conflicts with "${existing}".`
      );
    }
    usedSlugs.set(key, `${entryId} (${source})`);
  };

  // Track slugs per locale to detect duplicates
  const slugsByLanguage = new Map<string, Map<string, string>>();
  for (const code of languages) {
    slugsByLanguage.set(code, new Map());
  }

  for (const entry of allPages) {
    const language = getLanguageFromId(entry.id);
    const slug = getUrlSlug(entry);
    const isVariantOnly = Boolean((entry.data as any).variantOnly);

    if (!isVariantOnly) {
      // Check for duplicate permalinks within the same language
      const languageSlugMap = slugsByLanguage.get(language)!;
      if (languageSlugMap.has(slug)) {
        const existingId = languageSlugMap.get(slug);
        throw new Error(
          `Duplicate permalink "${slug || "/"}" for language "${language}": ` +
            `found in both "${existingId}" and "${entry.id}". ` +
            `Use unique permalinks or rename files.`
        );
      }
      languageSlugMap.set(slug, entry.id);
    }

    if (!isVariantOnly) {
      if (language === defaultLanguage) {
        // Default language: no prefix
        // /about, /docs/getting-started, / (empty slug)
        paths.push({
          params: { slug: slug || undefined },
          props: { entry, language, allPages },
        });
        addPath(slug, entry.id, "core");
      } else {
        // Non-default language: with prefix
        // /ru, /ru/about, /ru/docs/getting-started
        const fullSlug = slug ? `${language}/${slug}` : language;
        paths.push({
          params: { slug: fullSlug },
          props: { entry, language, allPages },
        });
        addPath(fullSlug, entry.id, "core");
      }
    }

    const idPath = getIdPath(entry.id);
    const pageType = resolvePageType({ idPath, data: entry.data });
    const variants = resolveRouteVariants(routeVariants, {
      entry,
      language,
      slug,
      idPath,
      pageType,
      allPages,
    });

    for (const variant of variants) {
      paths.push({
        params: { slug: variant.slug },
        props: { entry, language, allPages, routeVariant: variant },
      });
      addPath(variant.slug, entry.id, `variant:${variant.id}`);
    }
  }

  // Validate: no default language page should conflict with language prefixes
  const defaultLanguagePages = allPages.filter((p) => {
    if (getLanguageFromId(p.id) !== defaultLanguage) return false;
    return !(p.data as any).variantOnly;
  });
  const conflicts = defaultLanguagePages.filter((p) => {
    const slug = getUrlSlug(p);
    return secondaryLanguages.includes(slug as LanguageCode);
  });

  if (conflicts.length > 0) {
    const list = conflicts.map((p) => `"${p.id}"`).join(", ");
    throw new Error(
      `Default language pages cannot use slugs reserved for language prefixes: ${list}`
    );
  }

  return paths;
}

type RouteProps = {
  entry: CollectionEntry<"pages">;
  language: LanguageCode;
  allPages: CollectionEntry<"pages">[];
  routeVariant?: ResolvedRouteVariant;
};

const { entry, language, allPages, routeVariant } = Astro.props as RouteProps;
// Absolute URLs for SEO meta tags (hreflang, canonical)
const alternatesAbsolute = getAlternateUrls(entry, allPages, { absolute: true });
// Relative URLs for language switcher
const alternatesRelative = getAlternateUrls(entry, allPages);
const { Content } = await render(entry);

const idPath = getIdPath(entry.id);
const pageType = routeVariant?.pageType ?? resolvePageType({ idPath, data: entry.data });
const templateId = routeVariant?.template;
const layoutProps = routeVariant?.layoutProps ?? {};
const pageProps = routeVariant?.pageProps ?? {};
const Layout = await loadTemplateLayout(templateId);
const Page = await loadTemplatePage(pageType, templateId);
---

<Layout
  title={entry.data.title}
  description={entry.data.description}
  language={language}
  hreflangUrls={alternatesAbsolute}
  switcherUrls={alternatesRelative}
  {...layoutProps}
>
  <Page entry={entry} {...pageProps}>
    <Content />
  </Page>
</Layout>
